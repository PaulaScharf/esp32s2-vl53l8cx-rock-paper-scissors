// Code generated by senseBox Blockly on Wed Dec 18 2024 16:43:26 GMT+0100 (Central European Standard Time)

#include <vl53l8cx.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_NeoPixel.h>
#include <TensorFlowLite.h>
#include "tensorflow/lite/micro/kernels/micro_ops.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/all_ops_resolver.h"
#include "tensorflow/lite/schema/schema_generated.h"

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define SENSOR_WIDTH 8
#define SENSOR_HEIGHT 8
#define DISPLAY_WIDTH 64
#define DISPLAY_HEIGHT 64
#define SCALE_FACTOR 8
#define OLED_RESET -1
#define DURATION 3000

namespace {
  const tflite::Model* model = nullptr;
  tflite::MicroInterpreter* interpreter = nullptr;
  TfLiteTensor* model_input = nullptr;
  constexpr int kTensorArenaSize = 71*1028 + 128;
  uint8_t tensor_arena[kTensorArenaSize];
}

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
VL53L8CX sensor_vl53l8cx(&Wire, -1, -1);
float tofData[64] = {0};
uint16_t sensorBitmap[SENSOR_WIDTH * SENSOR_HEIGHT];
uint8_t scaledBitmap[DISPLAY_WIDTH * DISPLAY_HEIGHT / 8];

void setup() {
  Serial.begin(115200);
  Wire.begin();
  sensor_vl53l8cx.begin();
  sensor_vl53l8cx.init();
  sensor_vl53l8cx.start_ranging();
  display.begin(SSD1306_SWITCHCAPVCC, 0x3D);
  display.display();
  delay(100);
  display.clearDisplay();

  model = tflite::GetModel(get_model_data());
  static tflite::AllOpsResolver resolver;
  static tflite::MicroInterpreter static_interpreter(model, resolver, tensor_arena, kTensorArenaSize);
  interpreter = &static_interpreter;
  interpreter->AllocateTensors();
  model_input = interpreter->input(0);
}

bool getVl53l8cxBitmap() {
  VL53L8CX_ResultsData Result;
  uint8_t NewDataReady = 0;
  uint8_t status = sensor_vl53l8cx.check_data_ready(&NewDataReady);
  if (!status && NewDataReady != 0) {
    sensor_vl53l8cx.get_ranging_data(&Result);
    for (int j = 0; j < SENSOR_HEIGHT; j++) {
      for (int k = 0; k < SENSOR_WIDTH; k++) {
        int index = j * SENSOR_WIDTH + k;
        long distance = (long)(&Result)->distance_mm[VL53L8CX_NB_TARGET_PER_ZONE * index];
        if (distance > 400) distance = 400;
        sensorBitmap[index] = map(distance, 0, 400, 0, 5);
        tofData[j + k] = distance / 400.0;
      }
    }
    return true;
  }
  return false;
}

void loop() {
  unsigned long startTime = millis();
  float rockSum = 0, paperSum = 0, scissorsSum = 0;
  int count = 0;

  while (millis() - startTime < DURATION) {
    if (getVl53l8cxBitmap()) {
      for (int i = 0; i < 64; ++i) {
        model_input->data.f[i] = tofData[i];
      }
      
      if (interpreter->Invoke() == kTfLiteOk) {
        const float *prediction_scores = interpreter->output(0)->data.f;
        paperSum += prediction_scores[0];
        rockSum += prediction_scores[1];
        scissorsSum += prediction_scores[2];
        count++;
      }
    }
  }
  
  float avgRock = rockSum / count;
  float avgPaper = paperSum / count;
  float avgScissors = scissorsSum / count;
  String result = (avgRock > avgPaper && avgRock > avgScissors) ? "Rock" : (avgPaper > avgRock && avgPaper > avgScissors) ? "Paper" : "Scissors";
  
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE, BLACK);
  display.setCursor(20, 20);
  display.println(result);
  display.display();
}